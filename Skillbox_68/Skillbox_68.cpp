#include <iostream>
#include <vector>

using namespace std;

/*Задание 2. Крестики-нолики
Что нужно сделать
Старая добрая игра на страницах всех школьных тетрадей. 
Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. 
Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O 
(буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает. 
Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. 
Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.
Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). 
Это можно сделать сразу при объявлении либо с помощью вложенного цикла. 
На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, 
и игрок должен указать координаты клетки повторно. 
После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.*/

//------------------------------------------------------------------------------------------------------------------------
void displayBoard(const vector<vector<char>>& board) // метод для отображения текущего состояния поля
{
    for (const auto& row : board) 
    {
        for (char cell : row) 
        {
            cout << cell << " ";
        }
        cout << endl;
    }
}
//------------------------------------------------------------------------------------------------------------------------
bool checkWin(const vector<vector<char>>& board, char player) // метод для проверки победы
{
	// Проверка по горизонтали и вертикали
	for (int i = 0; i < 3; ++i)
	{
		if (board[i][0] == player && board[i][1] == player && board[i][2] == player)
		{
			return true; // Горизонталь
		}
		if (board[0][i] == player && board[1][i] == player && board[2][i] == player)
		{
			return true; // Вертикаль
		}
	}

	// Проверка по диагонали
	if (board[0][0] == player && board[1][1] == player && board[2][2] == player)
	{
		return true; // Главная диагональ
	}
	if (board[0][2] == player && board[1][1] == player && board[2][0] == player)
	{
		return true; // Побочная диагональ
	}

	return false;
}
//------------------------------------------------------------------------------------------------------------------------
int main()
{
	setlocale(LC_ALL, "ru");

	vector<vector<char>> board(3, vector<char>(3, ' ')); // Инициализация поля
	char currentPlayer = 'X'; // Игрок, который сейчас ходит

	// Игровой цикл
	for (int step = 0; step < 9; ++step) 
	{
		// Вывод текущего состояния поля
		displayBoard(board);

		// Ввод координат от игрока
		int row, col;
		cout << "Игрок " << currentPlayer << ", введите координаты (строка и столбец): ";
		cin >> row >> col;

		// Проверка на корректность ввода и доступность ячейки
		if (row < 0 || row >= 3 || col < 0 || col >= 3 || board[row][col] != ' ') 
		{
			cout << "Некорректный ход, повторите ввод." << endl;
			--step; // Чтобы повторить текущий ход
			continue;
		}

		// Установка символа в указанные координаты
		board[row][col] = currentPlayer;

		// Проверка на победу
		if (checkWin(board, currentPlayer)) 
		{
			displayBoard(board);
			cout << "Игрок " << currentPlayer << " победил!" << endl;
			return 0;
		}

		// Переключение на следующего игрока
		currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
	}

	// Если все ячейки заполнены, объявляем ничью
	displayBoard(board);
	cout << "Ничья!" << endl;

	return 0;
}
//------------------------------------------------------------------------------------------------------------------------